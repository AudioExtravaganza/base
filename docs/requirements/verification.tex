\section{Verification}

%\subsection{External Interfaces}

\subsection{Functions}
% Mason & Martin
% we already wrote this in the requirements.tex file?
    
    To verify the functionality of our product, we will run rigorous unit tests on each proposed function. While combining functionality, we will run integration tests to make sure that the overall product performs as expected with the subsystems connected. After combining any two functions, we will also need to run regression tests to make sure that the new modifications or additions did not impact the performance or output of any other component of the system.
    
   
\subsection{Usability Requirements}
% Alex & Devon
The usability standards established in Section 2.3 which provide concrete values (input response times, labelling standards, etc.) can be evaluated using appropriate measurement methods, or by simple observation of the product. Impression and opinion based user requirements will be collected from testing groups through standardized scales (1 - 10 rating). Requirements reliant on user actions will be measured based on observed usability sessions conducted with qualified individuals. User tests will be conducted with a diverse set of potential users including multiple levels of skill with electronic systems (musical and non-musical) and music. 

%Once our product is plugged into a power system, it should take at maximum one second for it to start generating the effects. This will be done using system outputs and testing\\
%Our testing of clearly defined features will be based off user feedback from our testing groups using a one to ten rating scale.\\
%The time to select an effect, trigger loop functionality, and create new scene configurations will be determined by timing 

\subsection{Performance Requirements}
From a performance standpoint, we can verify that the final product is operating per the specifications by performing a series of measurements and qualitative assessments. For measurable data, we can look assure the latency (the delay from input to output) is unnoticeable and is not additive in each subsequent loop. This likely means limiting acceptable latency to approximately 10ms. We can also approach this latency metric from the amount of processing we are doing for a signal. Latency should be very uniform regardless of the level of effects processing we are incurring, and should also be comparable to when the effects are engaged or in bypass mode. We can also verify that the device is maintaining its configurations and that the same effects are deterministic of the parameters. Finally, within the limitations of quantification, we can verify that the portability of the product will be comparable to other similar products, and that the mobility and implementation of the product is not an inhibitory factor to a performer. \\
Shifting to a more qualitative point of view, we can verify that the performance capabilities are on par by gaining feedback from performers on all levels of skill and experience. Perhaps the best way to determine if we have some performance-worthy product is by conducting surveys with the users themselves. We can also similarly ask audiences for their impressions, and we can try to gain valuable information from that to verify if the product performs as expected. 


\subsection{Design Constraints}
% Ben & Mason
The design constraints are fairly straightforward, factoring in cost and physical limitations of the equipment we are trying to use. To verify our product against the design constraints, we can check to make sure our goals were met while making sure we stay within the constraints of our project. One of these main constraints is the overall cost-to-make and potential price-to-purchase. While we wish our product to be robust, powerful, and unique, it cannot be prohibitively expensive, and there may be some areas of contention and trade-off between versatility and power over economics and simplicity. Additionally, we are at the mercy of hardware and software limitations, and while our research suggests all goals and stretch goals are possible, it is important to be able to deal with compromising in some areas. To verify our product fits within the design constraints, we must compare our costs and our goals to our final implementation and assure that our constraints were followed as closely as possible. 

\subsection{Software System Attributes}
% Alex
Verifying the reliability and ease of learning will be judged by our testing groups, using a one to ten rating scale. Our cost aspect will be monitored by the costs that go into making our final product. Lastly, testing the system boot time will either require using computer output, either to a monitor with the boot time or lighting up an onboard LED if we boot before a set time, or using external hardware such as video/audio to determine the time between plug-in and fully being on.

%\subsection{Supporting Information}

